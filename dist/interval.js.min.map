{"version":3,"sources":["interval/src/interval.js"],"names":["Interval","_this","this","_ref","arguments","length","undefined","_ref$callback","callback","_ref$ms","ms","_ref$start","start","isFunction","Error","checkTime","parseInt","interval","status","last","startInterval","_ref2","_ref2$callback","_ref2$ms","setInterval","stopInterval","_ref3$callback","clearInterval","deleteInterval","_ref4$callback","getStatus","setTime","mewMs","getTime"],"mappings":"AAAA,aAkBA,SAASA,WACP,IAAIC,EAAQC,KAERC,EAAOC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,GAC3EG,EAAgBJ,EAAKK,SACrBA,OAA6B,IAAlBD,EAA2B,aAAiBA,EACvDE,EAAUN,EAAKO,GACfA,OAAiB,IAAZD,EAAqB,IAAOA,EACjCE,EAAaR,EAAKS,MAClBA,OAAuB,IAAfD,GAA+BA,EAa3C,SAASE,WAAWL,GAClB,GAAwB,mBAAbA,EACT,OAAO,EAGT,MAAM,IAAIM,MAAM,gCAalB,SAASC,UAAUL,GASjB,GARU,MAANA,IACFA,EAAK,GAGW,iBAAPA,IACTA,EAAKM,SAASN,EAAI,KAGhBA,GAAMA,GAAM,EACd,MAAM,IAAII,MAAM,2BAGlB,OAAOJ,EAST,IAAIO,EAAW,KAOXC,GAAS,EAOTC,EAAO,CACTX,SAAU,KACVE,GAAI,MAENG,WAAWL,GACXW,EAAO,CACLX,SAAUA,EACVE,GAAIK,UAAUL,IAxELR,KAmFNkB,cAAgB,WACnB,IAAIC,EAAQjB,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,GAC5EkB,EAAiBD,EAAMb,SACvBA,OAA8B,IAAnBc,EAA4B,aAAiBA,EACxDC,EAAWF,EAAMX,GACjBA,OAAkB,IAAba,EAAsB,IAAOA,EAatC,OAXAJ,EAAKT,GAAKK,UAAUL,GAEhBG,WAAWL,KACbW,EAAKX,SAAWA,GAGbU,GAAsB,MAAZD,IACbA,EAAWO,YAAYL,EAAKX,SAAUW,EAAKT,IAC3CQ,GAAS,GAGJjB,GArGEC,KAgHNuB,aAAe,WAClB,IACIC,GADQtB,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,IACrDI,SACvBA,OAA8B,IAAnBkB,EAA4B,aAAiBA,EAW5D,OATIR,GAAsB,MAAZD,IACZU,cAAcV,GACdC,GAAS,GAGa,mBAAbV,GACTA,IAGKP,GA9HEC,KAyIN0B,eAAiB,WACpB,IACIC,GADQzB,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,IACrDI,SACvBA,OAA8B,IAAnBqB,EAA4B,aAAiBA,EAE5D5B,EAAMwB,aAAa,CACjBjB,SAAUA,IAGZS,EAAW,MAlJFf,KA2JN4B,UAAY,WACf,OAAOZ,GA5JEhB,KAqKN6B,QAAU,WACb,IAAIC,EAAQ5B,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,IAChFe,EAAKT,GAAKA,EACVA,EAAKK,UAAUiB,IAxKN9B,KAiLN+B,QAAU,WACb,OAAOvB,GAGLE,GArLOV,KAsLJkB,cAAcD","file":"interval.js","sourcesContent":["\"use strict\";\n\n/** Wrapper form Intervals that makes possible to control their flow.\r\n *\r\n * @constructor\r\n *\r\n * @param {object} [param={}]\r\n * @param {function} [param.callback=() => {}] Callback that gets executed in repetition.\r\n * @param {number} [param.ms=1000] Milliseconds on how often to execute the code.\r\n * @param {boolean} [param.start=true] If true, the interval start at the creation of the object.\r\n *\r\n * @throws Will throw an error if `callback` is not a function.\r\n * @throws Will throw an error if `ms` is less or equal than 0.\r\n *\r\n * @version 1.2.1\r\n *\r\n * @author Gennaro Landolfi <gennarolandolfi@codedwork.it>\r\n */\nfunction Interval() {\n  var _this = this;\n\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$callback = _ref.callback,\n      callback = _ref$callback === void 0 ? function () {} : _ref$callback,\n      _ref$ms = _ref.ms,\n      ms = _ref$ms === void 0 ? 1000 : _ref$ms,\n      _ref$start = _ref.start,\n      start = _ref$start === void 0 ? true : _ref$start;\n\n  var that = this;\n  /**\r\n   * Checks if a callback is a valid function.\r\n   *\r\n   * @param {function} callback Callback to be checked.\r\n   *\r\n   * @returns {boolean}\r\n   *\r\n   * @throws Will throw an error if the given callback isn't a valid function.\r\n   */\n\n  function isFunction(callback) {\n    if (typeof callback === 'function') {\n      return true;\n    }\n\n    throw new Error('Callback must be a function.');\n  }\n  /**\r\n   * Checks a given value is a valid time value.\r\n   *\r\n   * @param {number|string} ms Time in milliseconds to be checked.\r\n   *\r\n   * @returns {number}\r\n   *\r\n   * @throws Will throw an error if the given time is too low.\r\n   */\n\n\n  function checkTime(ms) {\n    if (ms == null) {\n      ms = 0;\n    }\n\n    if (typeof ms === 'string') {\n      ms = parseInt(ms, 10);\n    }\n\n    if (ms && ms <= 0) {\n      throw new Error('Wrong repetition delay.');\n    }\n\n    return ms;\n  }\n  /**\r\n   * Native interval ID.\r\n   *\r\n   * @type {null|number}\r\n   */\n\n\n  var interval = null;\n  /**\r\n   * Current status of the execution. If true, the interval is in repetition.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var status = false;\n  /**\r\n   * Cache of the old data.\r\n   *\r\n   * @type {{ms: number|null, callback: function|null}}\r\n   */\n\n  var last = {\n    callback: null,\n    ms: null\n  };\n  isFunction(callback);\n  last = {\n    callback: callback,\n    ms: checkTime(ms)\n  };\n  /**\r\n   * Starts the interval if paused.\r\n   *\r\n   * @param {function} callback\r\n   * @param {number} [ms = 1000]\r\n   *\r\n   * @returns {Interval}\r\n   */\n\n  that.startInterval = function () {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$callback = _ref2.callback,\n        callback = _ref2$callback === void 0 ? function () {} : _ref2$callback,\n        _ref2$ms = _ref2.ms,\n        ms = _ref2$ms === void 0 ? 1000 : _ref2$ms;\n\n    last.ms = checkTime(ms);\n\n    if (isFunction(callback)) {\n      last.callback = callback;\n    }\n\n    if (!status || interval == null) {\n      interval = setInterval(last.callback, last.ms);\n      status = true;\n    }\n\n    return _this;\n  };\n  /**\r\n   * Pauses the interval and executes a callback if provided.\r\n   *\r\n   * @param {function} callback\r\n   *\r\n   * @returns {Interval}\r\n   */\n\n\n  that.stopInterval = function () {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$callback = _ref3.callback,\n        callback = _ref3$callback === void 0 ? function () {} : _ref3$callback;\n\n    if (status && interval != null) {\n      clearInterval(interval);\n      status = false;\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n\n    return _this;\n  };\n  /**\r\n   * Deletes the interval executes a callback if provided.\r\n   *\r\n   * @param {function} callback\r\n   *\r\n   * @returns {Interval}\r\n   */\n\n\n  that.deleteInterval = function () {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$callback = _ref4.callback,\n        callback = _ref4$callback === void 0 ? function () {} : _ref4$callback;\n\n    _this.stopInterval({\n      callback: callback\n    });\n\n    interval = null;\n  };\n  /**\r\n   * Returns the execution status of the the interval.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  that.getStatus = function () {\n    return status;\n  };\n  /**\r\n   * Changes the time between each step of the execution.\r\n   *\r\n   * @param {number} [mewMs=1000] Time in milliseconds.\r\n   */\n\n\n  that.setTime = function () {\n    var mewMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n    last.ms = ms;\n    ms = checkTime(mewMs);\n  };\n  /**\r\n   * Returns the current setted time (in milliseconds).\r\n   *\r\n   * @returns {number}\r\n   */\n\n\n  that.getTime = function () {\n    return ms;\n  };\n\n  if (start) {\n    that.startInterval(last);\n  }\n}"]}